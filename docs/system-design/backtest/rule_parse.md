
- 历史数据引用（REF函数）
- 逻辑运算符组合（>,<,==,&,|）
- 时间序列数据的动态计算
缓存管理
- 使用series_cache缓存指标序列
- 不进行指标计算


# 属性​
- OPERATORS：存储 AST 节点类型与运算符的映射
- data：市场数据源（pd.DataFrame类型）
- _indicators：注册的指标函数字典，键为指标名（如 SMA），值为 IndicatorFunction对象
- series_cache：缓存已计算的指标序列


# 方法
## ​公有方法​：
- parse()：解析规则表达式并返回布尔结果
- get_or_create_series()：获取或生成指标序列

## ​私有方法​：
- _eval()：递归评估 AST 节点（支持比较、逻辑、函数调用等）
- _ref()：特殊函数，引用历史期数据（需显式计算 expr的序列）
- 指标计算函数（_sma, _rsi, _macd）



## 规则解析器实现

### 位置绑定机制
- 新增`evaluate_at(rule: str, index: int)`方法
- 将规则计算绑定到特定K线位置
- 示例：`parser.evaluate_at("SMA(5) > SMA(20)", 100)`计算第100根K线处的规则

### REF函数实现
- 递归回溯历史位置计算嵌套表达式
- 工作流程：
  1. 保存当前索引位置
  2. 回溯到目标位置（当前索引 - period）
  3. 计算嵌套表达式
  4. 恢复原始索引位置
- 支持任意深度的函数嵌套

### 缓存机制
- 使用`value_cache`缓存计算结果
- 缓存键格式：`函数名(参数)@位置`
- 示例：`SMA(close,5)@100`缓存第100根K线的SMA值

### 递归深度控制
- 设置最大递归深度（默认50）
- 防止无限递归导致栈溢出
- 超限时抛出`RecursionError`

### 边界处理
- 索引越界时返回0.0
- 空值处理返回0.0
- 错误处理抛出详细异常信息


# 已解决问题

## 时间序列偏移处理
- REF函数已实现递归回溯机制
- 不依赖固定索引，动态处理时间序列偏移
- 示例：`REF(SMA(close,5), 1) < SMA(close,5)`
  1. 设置当前索引为t
  2. 计算左侧：
     - 回溯到t-1位置
     - 计算SMA(close,5)@t-1
  3. 计算右侧：SMA(close,5)@t

## 参数格式
- REF函数参数格式：`REF(表达式, 周期)`
- 表达式可以是任意嵌套的函数调用
- 示例：`REF(SMA(close,5), 1)` 或 `REF(RSI(14), 2)`
