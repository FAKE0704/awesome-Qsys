# 用户输入
## 基本输入
回测时间范围​：起止日期（如 2020-01-01至 2025-01-01）。

​初始资金​：回测起始本金（如 100,000元）。

​标的选择​：股票/期货代码（如 AAPL或 600519.SH），支持多标的（逗号分隔）。
  - ​板块与行业筛选
  - 市值与流动性筛选
  - 因子预筛选

​数据频率​：分钟/日/周线（默认日线）。

​交易成本​：默认包含佣金（如 0.025%）和滑点（如 0.1%），支持自定义。

## 高级输入
### 买卖信号规则
通过函数或配置项定义买卖信号
- 使用AST解析技术指标表达式
- 预置常见指标函数库（SMA/RSI/MACD等）
- 不要动态解析
- 需要设计DSL（领域特定语言）解析器
- 前端
例如：
均线交叉：buy: SMA(5) > SMA(20); sell: SMA(5) < SMA(20)
动量策略：buy: Close > Close.shift(5); sell: Close < Close.shift(5)
(SMA(5) > SMA(20)) & (RSI(14) < 30) & (VOLUME > MA(VOLUME, 5))
- 信号验证机制
- 是否需支持跨周期指标（如日线RSI+5分钟MACD）？


### 仓位管理​规则
有什么好的方式？
按钮+输入
例：依次点击“仓位”“=>”“仓位”“/”“2”，公式栏自动对应生成公式，表示仓位减半。 类似苹果的快捷指令的编写。
自然语言交易指令生成，根据用户编辑的公式，自动生成自然语言理解：“将仓位减半。”

```python
class PositionManager:
    STRATEGIES = {
        'fixed_percent': lambda percent: ...,
        'kelly': lambda: ...,
        'pyramid': lambda levels: ...
    }
    
    def add_strategy(name, func):
        """注册自定义仓位策略"""
    
    def execute(capital, signal_strength):
        """执行仓位计算"""
```


# 系统输出

核心绩效指标（累计收益率，策略总收益、年化收益率、年化复合增长、夏普比率、风险调整后收益 、最大回撤、历史最大亏损幅度、胜率）

可视化图表（资金曲线图、回撤曲线图、交易信号图（在价格图上标注买卖点））

交易明细（可下载文件）
- csv文件下载大小的考虑

# 优化
事件驱动架构
向量化计算​：预计算技术指标（如移动平均），减少循环开销
缓存机制​：复用历史数据，避免重复加载 
异步执行，进度实时显示
增量计算​：仅当策略逻辑变更时重新计算信号，否则复用缓存。


# 触发顺序和关键模块
## 策略初始化阶段​
当检测到strategy="自定义规则"时，引擎会动态创建RuleBasedStrategy实例
策略依赖IndicatorService计算技术指标（如MACD/RSI），通过indicator_service参数注入
买卖规则从session状态获取buy_rule_expr/sell_rule_expr（用户在前端配置的规则表达式）

## 进度管理机制​
•
进度服务ProgressService实现任务生命周期管理：
start_task() → update_progress() → end_task()
•
进度模拟循环（0-100）实际开发中需替换为真实计算进度

## 核心回测执行​
•
engine.run()方法驱动时间范围遍历（start_date→end_date）
•
内部触发策略的on_bar()事件处理K线数据
•
资金曲线equity_records实时记录账户净值变化


### 
​StrategySignalEvent：策略生成的买卖信号
FillEvent：订单成交事件（含滑点、手续费）
我们正在开发量化交易系统的回测框架，这是基于事件架构的，目前已经实现的包括：对于回测期间的数据，每个时间点验证规则看是否出现买卖信号，若有则生成​StrategySignalEvent事件，然后由BactestEngine进行处理生成信号列signal并加入engine.data，目前需要继续进行后续的设计和开发，是否需要同步触发生成FillEvent进行订单的下达？买卖信号的实际是否执行应该在哪个模块的哪个类去处理？

```

### 回测框架设计建议

#### 1. 信号处理流程
```
StrategySignalEvent (策略信号)
       ↓
OrderManager (订单管理)
       ↓
RiskEngine (风控检查)
       ↓
ExecutionEngine (执行引擎)
       ↓
FillEvent (成交事件)
```

#### 2. 模块职责
- **OrderManager**
  - 将StrategySignalEvent转换为OrderEvent
  - 处理订单类型（市价/限价）、数量计算
  - 位于：`src/core/execution/OrderManager.py`

- **RiskEngine** 
  - 检查仓位、资金、风控规则
  - 位于：`src/core/risk/`（需新建）

- **ExecutionEngine**
  - 模拟订单撮合（回测）
  - 计算滑点/手续费
  - 生成FillEvent
  - 位于：`src/core/execution/ExecutionEngine.py`

#### 3. 需要确认的关键点
1. 现有`src/core/execution/`目录是否包含订单管理逻辑？
2. 是否需要支持多种订单类型（市价/限价/IOC等）？
3. 滑点模型和手续费规则的具体需求？

#### 4. 下一步建议
1. 检查现有代码结构（特别是`src/core/execution/`）
2. 根据检查结果设计具体实现方案
3. 制定开发计划（新建模块或扩展现有代码）

是否同意此设计方案？如需查看具体文件内容，我可立即分析相关代码。

```

## 结果返回与可视化​
•
通过engine.get_results()提取绩效指标（夏普率/最大回撤）
•
前端调用st.success()和图表库展示资金曲线/交易信号
