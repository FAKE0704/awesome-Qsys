<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>量化平台任务管理系统</title>
    <style>
        /* 保持原有折叠面板样式 */
        .task-manager { max-width: 1000px; margin: 20px auto; }
        .task-item { border-left: 3px solid #e0e0e0; margin: 5px 0 5px 15px; }
        .task-header { padding: 12px; background: #f8f9fa; cursor: pointer; }
        .task-content { max-height: 0; overflow: hidden; transition: max-height 0.3s; }
        .expanded .task-content { max-height: 2000px; }

        /* 新增导入按钮样式 */
        .import-btn {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #fileInput { display: none; }
    </style>
    <script src="marked.min.js"></script> <!-- 确保路径正确 -->
    <script src="purify.min.js"></script> <!-- 确保路径正确 -->
    
</head>
<body>
    <div class="task-manager">
        <button class="import-btn" onclick="document.getElementById('fileInput').click()">导入MD文件</button>
        <input type="file" id="fileInput" accept=".md" onchange="handleFileSelect(event)">
        <button id="global-control">全部展开</button>
        <div id="taskContainer"></div>
    </div>

<script>
// 配置增强型Markdown渲染器
const renderer = new marked.Renderer();
let currentParent = null; // 确保全局变量已声明
let lastLevel = 0;

// 修复标题层级关系的逻辑
renderer.heading = (text, level) => {
    // 如果 text 是对象类型，提取其 text 属性
    if (typeof text === 'object' && text.text) {
        text = text.text;
    }

    const taskItem = document.createElement('div');
    taskItem.className = 'task-item';
    taskItem.innerHTML = `
        <div class="task-header" onclick="toggleTask(this)">
            <span class="task-title">${text}</span>
            <span class="status-indicator">▶ 折叠</span>
        </div>
        <div class="task-content"></div>
    `;

    // 动态调整层级关系
    if (level > lastLevel && currentParent) {
        const contentDiv = currentParent.querySelector('.task-content');
        contentDiv.appendChild(taskItem);
    } else if (level <= lastLevel) {
        let parent = currentParent;
        for (let i = 0; i < lastLevel - level + 1; i++) {
            parent = parent?.parentElement?.closest('.task-item') || null;
        }
        if (parent) {
            const contentDiv = parent.querySelector('.task-content');
            contentDiv.appendChild(taskItem);
        } else {
            document.getElementById('taskContainer').appendChild(taskItem);
        }
    } else {
        document.getElementById('taskContainer').appendChild(taskItem);
    }
    currentParent = taskItem;
    lastLevel = level;
    return ''; // 返回空字符串，避免重复插入 HTML
};

// 修复列表项解析逻辑
renderer.listitem = (text, task, checked) => {
    // 如果 text 是对象类型，提取其 text 属性
    if (typeof text === 'object' && text.text) {
        text = text.text;
    }

    const li = document.createElement('div');
    li.className = 'subtask-item';

    // 根据传入的 task 和 checked 参数设置复选框状态
    li.innerHTML = `
        <label class="task-checkbox">
            <input type="checkbox" ${task && checked ? 'checked' : ''}>
            <span>${text}</span>
        </label>
    `;

    // 确保正确的父子关系
    if (currentParent) {
        const contentDiv = currentParent.querySelector('.task-content');
        contentDiv.appendChild(li);
    }
    return ''; // 返回空字符串，避免重复插入 HTML
};

// 修复文件上传逻辑
async function handleFileSelect(event) {
    try {
        const file = event.target.files[0];
        if (!file || !file.name.endsWith('.md')) {
            throw new Error('请选择有效的 .md 文件');
        }

        const reader = new FileReader();
        reader.onload = async (e) => {
            const mdContent = e.target.result;

            // 初始化解析状态
            currentParent = null; // 确保每次解析前初始化
            lastLevel = 0;

            // 检查 DOMPurify 是否正确加载
            if (typeof DOMPurify === 'undefined') {
                throw new Error('DOMPurify 未正确加载，请检查依赖');
            }

            // 安全解析 Markdown 内容
            const sanitizedContent = DOMPurify.sanitize(mdContent);

            // 使用 marked 解析 Markdown 内容
            marked.parse(sanitizedContent, {
                renderer,
                gfm: true,
                breaks: true,
                smartLists: true
            });

            // 绑定交互事件
            bindToggleEvents();
        };
        reader.readAsText(file);
    } catch (error) {
        console.error('文件处理失败:', error);
        alert(`上传失败: ${error.message}`);
    }
}

// 修复事件绑定逻辑
function bindToggleEvents() {
    document.querySelectorAll('.task-header').forEach(header => {
        header.onclick = function() {
            const taskItem = this.parentElement;
            const isExpanded = taskItem.classList.toggle('expanded');
            this.querySelector('.status-indicator').textContent = 
                isExpanded ? "▼ 已展开" : "▶ 折叠";
        };
    });
}

// 全局展开控制（保持原有逻辑）
let isAllExpanded = false;
document.getElementById('global-control').addEventListener('click', () => {
    const tasks = document.querySelectorAll('.task-item');
    isAllExpanded = !isAllExpanded;
    tasks.forEach(task => {
        task.classList.toggle('expanded', isAllExpanded);
        task.querySelector('.status-indicator').textContent = 
            isAllExpanded ? "▼ 已展开" : "▶ 折叠";
    });
    document.getElementById('global-control').textContent = 
        isAllExpanded ? '全部折叠' : '全部展开';
});
</script>
</body>
</html>